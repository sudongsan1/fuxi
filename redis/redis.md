#### RBD和AOF

- rdb通过创建快照来存储内存中某个时间点上的副本，创建快照之后可以对快照进行备份，复制到其它从节点或者云端。创建快照的方式是用bgsave命令，执行bgsave，父进程会fork出一个子进程，然后子进程负责将快照写入磁盘，父进程继续处理请求。可以在配置文件中配置save命令，达到条件后，会自动触发bgsave，执行快照持久化。
- aof将每条更改数据的命令写入硬盘中aof文件中。选择每秒钟将多个命令同步到硬盘。然后与rdb相比，aof的实时性更好，默认情况下没有开启，可以通过appendonly参数开启。当aof文件体积太大的时候，通过bgrewrite命名对aof文件进行压缩。

#### redis主从复制原理

完全复制

部分复制：runid,offset

![1570499595055](C:\Users\WPC\AppData\Roaming\Typora\typora-user-images\1570499595055.png)

![1570499658743](C:\Users\WPC\AppData\Roaming\Typora\typora-user-images\1570499658743.png)![1570499670709](C:\Users\WPC\AppData\Roaming\Typora\typora-user-images\1570499670709.png)

http://blog.itpub.net/31545684/viewspace-2213629/

https://blog.csdn.net/fst438060684/article/details/80958375

https://blog.csdn.net/xuxian6823091/article/details/81195231

#### 缓存不一致解决方案

（1）读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应

（2）更新的时候，先删除缓存，然后再更新数据库

为什么不是更新缓存？

1.更新缓存的代价是很高的

2.这个缓存到底会不会被频繁访问到，每次数据过来，就只是删除缓存，然后修改数据库，如果这个缓存，在1分钟内只是被访问了1次，那么只有那1次，缓存是要被重新计算的，用缓存才去算缓存，用缓存的时候采取计算缓存

搞一个队列，读请求如果没有命中缓存，根据数据的唯一标识，将操作路由之后就进入队列，更新操作同样进入队列

待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中

如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回; 如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值