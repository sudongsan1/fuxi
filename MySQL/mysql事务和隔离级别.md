## mysql事务和隔离级别

### 什么是事务？

**事务是逻辑上的一组操作，要么都执行，要么都不执行。**

**我们把需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称之为一个事务。**

### 事务的四大特性

场景：小明向小强转账10元

**原子性(Atomic)**

转账操作是一个不可分割的操作，要么转失败，要么转成功，不能存在中间的状态，也就是转了一半的这种情
况。我们把这种要么全做，要么全不做的规则称之为原子性。

**隔离性(Isolation)**

另外一个场景：
1. 小明向小强转账10元
2. 小明向小红转账10元
隔离性表示上面两个操作是不能相互影响的

**一致性(Consistency)**

对于上面的转账场景，一致性表示每一次转账完成后，都需要保证整个系统的余额等于所有账户的收入减去所有
账户的支出。
如果不遵循原子性，也就是如果小明向小强转账10元，但是只转了一半，小明账户少了10元，小强账户并没有增
加，所以没有满足一致性了。
同样，如果不满足隔离性，也有可能导致破坏一致性。
所以说，数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后保证符合所有既定的
约束则是一种结果。

**持久性(Durability)**

对于转账的交易记录，需要永久保存。

### 事务的隔离级别

**读未提交(read uncommited)**

一个事务可以读到其他事务还没有提交的数据，会出现脏读。

**读已提交(read commited)**

一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事
务都能查询得到最新值，**但是会出现不可重复读、幻读**。

**可重复读(repetable read)**

一个事务第一次读过某条记录后，即使其他事务修改了该记录的值并且提交，该事务之后再读该条记录时，读到
的仍是第一次读到的值，而不是每次都读到不同的数据，这就是可重复读，这种隔离级别解决了不可重复，但是
还是会出现幻读。

如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先
的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，这就是**幻读**。

**串行化(serializable)**

以上3种隔离级别都允许对同一条记录同时进行**读-读、读-写、写-读**的并发操作，如果我们不允许读-写、写-读
的并发操作，可以使用SERIALIZABLE隔离级别，这种隔离基金因为对同一条记录的操作都是串行的，所以不会
出现脏读、幻读等现象。

### 多版本并发控制MVCC

在数据库中，并发控制是指在多个用户/进程/线程同时对数据库进行操作时，如何保证事务的一致性和隔离性的，同时最大程度地并发。

当多个用户/进程/线程同时对数据库进行操作时，会出现3种冲突情形：
**1.读-读，不存在任何问题**

**2.读-写，有隔离性问题，可能遇到脏读（会读到未提交的数据） ，幻影读等。**

**3.写-写，可能丢失更新**

要解决冲突，一种办法是是锁，即基于锁的并发控制，比如2PL，这种方式开销比较高，而且无法避免死锁。

多版本并发控制（MVCC）是一种用来**解决读-写冲突**的无锁并发控制，<font color=Red>也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照</font>。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，**避免了脏读和不可重复读**



乐观并发控制（OCC）是一种用来**解决写-写冲突**的无锁并发控制，认为事务间争用没有那么多，所以先进行修改，在提交事务前，检查一下事务开始后，有没有新提交改变，如果没有就提交，如果有就放弃并重试。乐观并发控制类似自选锁。乐观并发控制适用于低数据争用，写冲突比较少的环境。

多版本并发控制可以结合基于锁的并发控制来解决写-写冲突，即MVCC+2PL，也可以结合乐观并发控制来解决写-写冲突。

[乐观锁和 MVCC 的区别](https://www.zhihu.com/question/27876575)

