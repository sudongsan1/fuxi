## 锁分类

### 按粒度分

1. 表级锁：粒度大，并发低
2. 行级锁：粒度小，并发高

行级锁又可分为：

1. LOCK_REC_NOT_GAP：单个行记录上的锁。
2. LOCK_GAP：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务
   的两次当前读，出现幻读的情况。
3. LOCK_ORDINARY：锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要
   目的是解决幻读的问题。

**相关知识点：**

1. nnodb对于行的查询使用next-key lock
2. Next-locking keying为了解决Phantom Problem幻读问题
3. 当查询的索引含有唯一属性时，将next-key lock降级为record key
4. **Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生**
5. 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1

### 按读写分

1. X锁：写锁
2. S锁：读锁

对数据可以同时加读锁，不能同时加读写锁，写写锁

### 意向共享锁

IS，IX

IS锁：意向共享锁、Intention Shared Lock。当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁。

IX锁，意向排他锁、Intention Exclusive Lock。当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁。

IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以
**避免用遍历的方式来查看表中有没有上锁的记录**。

### 锁和索引的关系

​	假设有一张消息表（msg）,里面有3个字段。假设id是主键，token是非唯一索引，message没有索引。

| id：bigint | token:vachar(30) | message:vachar(4096) |

1.delete from msg where id =2;

主键索引锁住主键对应整行记录

2.delete from msg where token=’ cvs’;

非唯一索引先锁住二级索引，接着锁住相对应的主键索引

3.delete from msg where message=订单号是多少’；

没有建立索引，走全表扫描过滤，分为两种情况RC对相应的行加锁，RR对表中所有记录以及间隙加锁。

### 锁和隔离级别的关系

经常使用的是RC和RR

提交读(RC)：只能读取到已经提交的数据。

可重复读(RR)：在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。

**上面讨论的加锁是在RC隔离级别下的，innodb的RR隔离级别可以避免幻读发生，怎么实现？当然需要借助于锁了！**

为了解决幻读问题，innodb引入了gap锁。比如在事务A执行：update msg set message=‘订单’ where token=‘asd’;

innodb首先会和RC级别一样，给索引上的记录添加上X锁，此外，还在非唯一索引’asd’与相邻两个索引的区间加上锁。

这样，当事务B在执行insert into msg values (null,‘asd',’hello’); commit;时，会首先检查这个区间是否被锁上，如果被锁上，则不能立即执行，需要等待该gap锁被释放。这样就能避免幻读问题。

### 死锁成因

死锁一般是事务相互等待对方资源，最后形成环路造成的。

#### 检测死锁

**1.设置等待时间**

在两个事务相互等待是，当一个等待时间超过设置的某一阈值时，对其中一个进行回滚，另一个就能继续执行，这种方法简单有效，在innodb中，参数innodb_lock_wait_timeout用来设置超时时间。

**2.wait-for graph原理**

 **innodb将各个事务看为一个个节点**，资源就是各个事务占用的锁，当事务1需要等待事务2的锁时，就生成一条有向边从1指向2，最后行成一个有向图。

![image.png](https://upload-images.jianshu.io/upload_images/4237057-4a3154331ff88eb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 如何避免死锁

1.以**固定的顺序**访问表和行

2.**大事务拆小**。大事务更倾向于死锁，如果业务允许，将大事务拆小。

3.在同一个事务中，**尽可能做到一次锁定所需要的所有资源**，减少死锁概率。

4.**为表添加合理的索引**。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。

[mysql死锁问题分析](https://www.cnblogs.com/LBSer/p/5183300.html)

### 悲观锁和乐观锁

#### 乐观锁

乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

**CAS便是乐观锁技术**，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

#### 悲观锁

悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

比如说 synchronized 和 ReentrantLock 就是独占锁，他假设最坏的情况，并且只有在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。

**缺点：**
由于在进程挂起和恢复执行过程中存在着很大的开销。当一个线程正在等待锁时，它不能做任何事。举个栗子，如果一个线程需要某个资源，但是这个资源的占用时间很短，当线程第一次抢占这个资源时，可能这个资源被占用，如果此时挂起这个线程，可能立刻就发现资源可用，然后又需要花费很长的时间重新抢占锁，时间代价就会非常的高。

[乐观锁和悲观锁](https://www.cnblogs.com/zhengbin/p/5657435.html)